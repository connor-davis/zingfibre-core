// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dynamic_queries.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
)

const createDynamicQuery = `-- name: CreateDynamicQuery :one
INSERT INTO
    dynamic_queries (
        query_name,
        is_primary
    )
VALUES
    ($1, $2)
RETURNING
    id, query_name, is_primary, created_at, updated_at
`

type CreateDynamicQueryParams struct {
	QueryName string
	IsPrimary bool
}

func (q *Queries) CreateDynamicQuery(ctx context.Context, arg CreateDynamicQueryParams) (DynamicQuery, error) {
	row := q.db.QueryRow(ctx, createDynamicQuery, arg.QueryName, arg.IsPrimary)
	var i DynamicQuery
	err := row.Scan(
		&i.ID,
		&i.QueryName,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDynamicQuery = `-- name: DeleteDynamicQuery :exec
DELETE FROM
    dynamic_queries
WHERE
    id = $1
`

func (q *Queries) DeleteDynamicQuery(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDynamicQuery, id)
	return err
}

const getDynamicQueries = `-- name: GetDynamicQueries :many
SELECT
    id, query_name, is_primary, created_at, updated_at
FROM
    dynamic_queries
ORDER BY
    query_name ASC
`

func (q *Queries) GetDynamicQueries(ctx context.Context) ([]DynamicQuery, error) {
	rows, err := q.db.Query(ctx, getDynamicQueries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DynamicQuery
	for rows.Next() {
		var i DynamicQuery
		if err := rows.Scan(
			&i.ID,
			&i.QueryName,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDynamicQuery = `-- name: GetDynamicQuery :one
SELECT
    id, query_name, is_primary, created_at, updated_at
FROM
    dynamic_queries
WHERE
    id = $1
LIMIT
    1
`

func (q *Queries) GetDynamicQuery(ctx context.Context, id uuid.UUID) (DynamicQuery, error) {
	row := q.db.QueryRow(ctx, getDynamicQuery, id)
	var i DynamicQuery
	err := row.Scan(
		&i.ID,
		&i.QueryName,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDynamicQueryChildQueries = `-- name: GetDynamicQueryChildQueries :many
SELECT
    t1.id, t1.query_name, t1.is_primary, t1.created_at, t1.updated_at
FROM
    dynamic_queries t1
LEFT JOIN dynamic_query_child_queries t2 ON t2.child_query_id = t1.id
WHERE
    t2.dynamic_query_id = $1
ORDER BY
    t1.query_name ASC
`

func (q *Queries) GetDynamicQueryChildQueries(ctx context.Context, dynamicQueryID uuid.UUID) ([]DynamicQuery, error) {
	rows, err := q.db.Query(ctx, getDynamicQueryChildQueries, dynamicQueryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DynamicQuery
	for rows.Next() {
		var i DynamicQuery
		if err := rows.Scan(
			&i.ID,
			&i.QueryName,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDynamicQueryClauses = `-- name: GetDynamicQueryClauses :many
SELECT
    t1.id, t1.dynamic_query_id, t1.clause_column, t1.clause_operator, t1.clause_value, t1.created_at, t1.updated_at
FROM
    dynamic_query_clauses t1
WHERE
    t1.dynamic_query_id = $1
ORDER BY
    t1.clause_column ASC,
    t1.clause_operator ASC,
    t1.clause_value ASC
`

func (q *Queries) GetDynamicQueryClauses(ctx context.Context, dynamicQueryID uuid.UUID) ([]DynamicQueryClause, error) {
	rows, err := q.db.Query(ctx, getDynamicQueryClauses, dynamicQueryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DynamicQueryClause
	for rows.Next() {
		var i DynamicQueryClause
		if err := rows.Scan(
			&i.ID,
			&i.DynamicQueryID,
			&i.ClauseColumn,
			&i.ClauseOperator,
			&i.ClauseValue,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDynamicQueryColumns = `-- name: GetDynamicQueryColumns :many
SELECT
    t1.id, t1.dynamic_query_id, t1.column_table, t1.column_name, t1.column_label, t1.created_at, t1.updated_at
FROM
    dynamic_query_columns t1
WHERE
    t1.dynamic_query_id = $1
ORDER BY
    t1.column_name ASC,
    t1.column_table ASC,
    t1.column_label ASC
`

func (q *Queries) GetDynamicQueryColumns(ctx context.Context, dynamicQueryID uuid.UUID) ([]DynamicQueryColumn, error) {
	rows, err := q.db.Query(ctx, getDynamicQueryColumns, dynamicQueryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DynamicQueryColumn
	for rows.Next() {
		var i DynamicQueryColumn
		if err := rows.Scan(
			&i.ID,
			&i.DynamicQueryID,
			&i.ColumnTable,
			&i.ColumnName,
			&i.ColumnLabel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDynamicQueryJoins = `-- name: GetDynamicQueryJoins :many
SELECT
    t1.id, t1.dynamic_query_id, t1.join_left_table, t1.join_left_column, t1.join_right_table, t1.join_right_column, t1.join_type, t1.created_at, t1.updated_at
FROM
    dynamic_query_joins t1
WHERE
    t1.dynamic_query_id = $1
ORDER BY
    t1.join_left_table ASC,
    t1.join_left_column ASC,
    t1.join_right_table ASC,
    t1.join_right_column ASC
`

func (q *Queries) GetDynamicQueryJoins(ctx context.Context, dynamicQueryID uuid.UUID) ([]DynamicQueryJoin, error) {
	rows, err := q.db.Query(ctx, getDynamicQueryJoins, dynamicQueryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DynamicQueryJoin
	for rows.Next() {
		var i DynamicQueryJoin
		if err := rows.Scan(
			&i.ID,
			&i.DynamicQueryID,
			&i.JoinLeftTable,
			&i.JoinLeftColumn,
			&i.JoinRightTable,
			&i.JoinRightColumn,
			&i.JoinType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDynamicQueryOrders = `-- name: GetDynamicQueryOrders :many
SELECT
    t1.id, t1.dynamic_query_id, t1.order_column, t1.order_type, t1.created_at, t1.updated_at
FROM
    dynamic_query_orders t1
WHERE
    t1.dynamic_query_id = $1
ORDER BY
    t1.order_column ASC,
    t1.order_type ASC
`

func (q *Queries) GetDynamicQueryOrders(ctx context.Context, dynamicQueryID uuid.UUID) ([]DynamicQueryOrder, error) {
	rows, err := q.db.Query(ctx, getDynamicQueryOrders, dynamicQueryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DynamicQueryOrder
	for rows.Next() {
		var i DynamicQueryOrder
		if err := rows.Scan(
			&i.ID,
			&i.DynamicQueryID,
			&i.OrderColumn,
			&i.OrderType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDynamicQuery = `-- name: UpdateDynamicQuery :one
UPDATE dynamic_queries
SET
    query_name = $1,
    is_primary = $2,
    updated_at = now()
WHERE
    id = $3
RETURNING
    id, query_name, is_primary, created_at, updated_at
`

type UpdateDynamicQueryParams struct {
	QueryName string
	IsPrimary bool
	ID        uuid.UUID
}

func (q *Queries) UpdateDynamicQuery(ctx context.Context, arg UpdateDynamicQueryParams) (DynamicQuery, error) {
	row := q.db.QueryRow(ctx, updateDynamicQuery, arg.QueryName, arg.IsPrimary, arg.ID)
	var i DynamicQuery
	err := row.Scan(
		&i.ID,
		&i.QueryName,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
