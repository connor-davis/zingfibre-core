// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: addresses.sql

package zing

import (
	"context"
	"database/sql"
)

const getAddress = `-- name: GetAddress :one
SELECT
    id, erf, streetaddress, mduname, mduunitnumber, mdublock, township, propertytype, pop, installdate, radiususername, radiuspassword, installcomplete, w3w, installstate, polenumber, serviceid, buildid, salesagentid, datecreated, deleted
FROM
    Addresses
WHERE
    id = ?
LIMIT
    1
`

func (q *Queries) GetAddress(ctx context.Context, id string) (Address, error) {
	row := q.db.QueryRowContext(ctx, getAddress, id)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.Erf,
		&i.Streetaddress,
		&i.Mduname,
		&i.Mduunitnumber,
		&i.Mdublock,
		&i.Township,
		&i.Propertytype,
		&i.Pop,
		&i.Installdate,
		&i.Radiususername,
		&i.Radiuspassword,
		&i.Installcomplete,
		&i.W3w,
		&i.Installstate,
		&i.Polenumber,
		&i.Serviceid,
		&i.Buildid,
		&i.Salesagentid,
		&i.Datecreated,
		&i.Deleted,
	)
	return i, err
}

const getAddresses = `-- name: GetAddresses :many
SELECT
    id, erf, streetaddress, mduname, mduunitnumber, mdublock, township, propertytype, pop, installdate, radiususername, radiuspassword, installcomplete, w3w, installstate, polenumber, serviceid, buildid, salesagentid, datecreated, deleted
FROM
    Addresses
LIMIT
    ?
OFFSET
    ?
`

type GetAddressesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetAddresses(ctx context.Context, arg GetAddressesParams) ([]Address, error) {
	rows, err := q.db.QueryContext(ctx, getAddresses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Address
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.Erf,
			&i.Streetaddress,
			&i.Mduname,
			&i.Mduunitnumber,
			&i.Mdublock,
			&i.Township,
			&i.Propertytype,
			&i.Pop,
			&i.Installdate,
			&i.Radiususername,
			&i.Radiuspassword,
			&i.Installcomplete,
			&i.W3w,
			&i.Installstate,
			&i.Polenumber,
			&i.Serviceid,
			&i.Buildid,
			&i.Salesagentid,
			&i.Datecreated,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPOPs = `-- name: GetPOPs :many
SELECT
    POP AS pop
FROM
    Addresses
WHERE
    POP IS NOT NULL
GROUP BY
    POP
ORDER BY
    pop ASC
`

func (q *Queries) GetPOPs(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getPOPs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var pop sql.NullString
		if err := rows.Scan(&pop); err != nil {
			return nil, err
		}
		items = append(items, pop)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
