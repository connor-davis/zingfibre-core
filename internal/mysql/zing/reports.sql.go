// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reports.sql

package zing

import (
	"context"
	"database/sql"
	"time"
)

const getReportsCustomers = `-- name: GetReportsCustomers :many
SELECT
    CONCAT(t1.FirstName, ' ', t1.Surname) AS full_name,
    t1.Email AS email,
    t2.RadiusUsername AS radius_username,
    t1.PhoneNumber AS phone_number
FROM Customers t1
LEFT JOIN Addresses t2 ON t1.AddressId = t2.Id
WHERE
    TRIM(LOWER(t2.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND (
        t1.FirstName LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Surname LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Email LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.PhoneNumber LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t2.RadiusUsername LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
ORDER BY
    CONCAT(t1.FirstName, ' ', t1.Surname) ASC,
    t1.Email ASC
LIMIT ?
OFFSET ?
`

type GetReportsCustomersParams struct {
	Poi    string
	Search string
	Limit  int32
	Offset int32
}

type GetReportsCustomersRow struct {
	FullName       string
	Email          sql.NullString
	RadiusUsername sql.NullString
	PhoneNumber    sql.NullString
}

func (q *Queries) GetReportsCustomers(ctx context.Context, arg GetReportsCustomersParams) ([]GetReportsCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsCustomers,
		arg.Poi,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsCustomersRow
	for rows.Next() {
		var i GetReportsCustomersRow
		if err := rows.Scan(
			&i.FullName,
			&i.Email,
			&i.RadiusUsername,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsExpiringCustomers = `-- name: GetReportsExpiringCustomers :many
SELECT
    CONCAT(t1.FirstName, ' ', t1.Surname) AS full_name,
    t1.Email AS email,
    t1.PhoneNumber AS phone_number,
    t4.RadiusUsername AS radius_username,
    t3.Name AS last_purchase_duration,
    t3.Category AS last_purchase_speed,
    CONCAT(?) AS expiration,
    CONCAT(?) AS address
FROM
    Customers t1
LEFT JOIN (
    SELECT
        CustomerID,
        MAX(DateCreated) AS LastRechargeDate
    FROM
        Recharges
    GROUP BY
        CustomerID
) AS latest_recharge ON t1.Id = latest_recharge.CustomerID
LEFT JOIN Recharges t2 ON latest_recharge.CustomerID = t2.CustomerID AND latest_recharge.LastRechargeDate = t2.DateCreated
LEFT JOIN Products t3 ON t2.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t1.AddressId = t4.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND (
        t1.FirstName LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Surname LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Email LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.PhoneNumber LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.RadiusUsername LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t3.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t3.Category LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
ORDER BY
    CONCAT(t1.FirstName, ' ', t1.Surname) ASC,
    t1.Email ASC
LIMIT ?
OFFSET ?
`

type GetReportsExpiringCustomersParams struct {
	Expiration interface{}
	Address    interface{}
	Poi        string
	Search     string
	Limit      int32
	Offset     int32
}

type GetReportsExpiringCustomersRow struct {
	FullName             string
	Email                sql.NullString
	PhoneNumber          sql.NullString
	RadiusUsername       sql.NullString
	LastPurchaseDuration sql.NullString
	LastPurchaseSpeed    sql.NullString
	Expiration           string
	Address              string
}

func (q *Queries) GetReportsExpiringCustomers(ctx context.Context, arg GetReportsExpiringCustomersParams) ([]GetReportsExpiringCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsExpiringCustomers,
		arg.Expiration,
		arg.Address,
		arg.Poi,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsExpiringCustomersRow
	for rows.Next() {
		var i GetReportsExpiringCustomersRow
		if err := rows.Scan(
			&i.FullName,
			&i.Email,
			&i.PhoneNumber,
			&i.RadiusUsername,
			&i.LastPurchaseDuration,
			&i.LastPurchaseSpeed,
			&i.Expiration,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsRechargeTypeCounts = `-- name: GetReportsRechargeTypeCounts :many
SELECT
	recharge_name, recharge_count, recharge_period, recharge_max_date
FROM
	(
		SELECT
			t3.Name AS recharge_name,
			COUNT(*) AS recharge_count,
			CASE
				WHEN ? = 'weeks' THEN CONCAT(
					FLOOR((DAY(t1.DateCreated) - 1) / 7) + 1,
					'-',
					MONTH(t1.DateCreated),
					'-',
					YEAR(t1.DateCreated)
				)
				WHEN ? = 'months' THEN CONCAT(MONTH(t1.DateCreated), '-', YEAR(t1.DateCreated))
			END AS recharge_period,
			MAX(t1.DateCreated) AS recharge_max_date
		FROM
			Recharges t1
			LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
			LEFT JOIN Products t3 ON t1.ProductId = t3.Id
            LEFT JOIN Addresses t4 ON t2.AddressId = t4.Id
		WHERE
			TRIM(LOWER(t4.POP)) = TRIM(LOWER(?))
			AND(
                (
                    ? = 'weeks'
                    AND t1.DateCreated >= 
                        CASE 
                            WHEN ? = 1 THEN DATE_FORMAT(NOW(), '%Y-%m-01 00:00:00')
                            ELSE DATE_FORMAT(DATE_SUB(DATE_FORMAT(NOW(), '%Y-%m-01'), INTERVAL (? - 1) WEEK), '%Y-%m-01 00:00:00')
                        END
                )
                OR(
                    ? = 'months'
                    AND t1.DateCreated >= 
                        CASE 
                            WHEN ? = 1 THEN DATE_FORMAT(NOW(), '%Y-%m-01 00:00:00')
                            ELSE DATE_FORMAT(DATE_SUB(DATE_FORMAT(NOW(), '%Y-%m-01'), INTERVAL (? - 1) MONTH), '%Y-%m-01 00:00:00')
                        END
                )
			)
		GROUP BY
			recharge_name,
			recharge_period
	) AS sub
ORDER BY
	recharge_max_date ASC,
    recharge_count DESC
`

type GetReportsRechargeTypeCountsParams struct {
	Period interface{}
	Poi    string
	Count  interface{}
}

type GetReportsRechargeTypeCountsRow struct {
	RechargeName    sql.NullString
	RechargeCount   int64
	RechargePeriod  interface{}
	RechargeMaxDate interface{}
}

func (q *Queries) GetReportsRechargeTypeCounts(ctx context.Context, arg GetReportsRechargeTypeCountsParams) ([]GetReportsRechargeTypeCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsRechargeTypeCounts,
		arg.Period,
		arg.Period,
		arg.Poi,
		arg.Period,
		arg.Count,
		arg.Count,
		arg.Period,
		arg.Count,
		arg.Count,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsRechargeTypeCountsRow
	for rows.Next() {
		var i GetReportsRechargeTypeCountsRow
		if err := rows.Scan(
			&i.RechargeName,
			&i.RechargeCount,
			&i.RechargePeriod,
			&i.RechargeMaxDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsRecharges = `-- name: GetReportsRecharges :many
SELECT
    t1.DateCreated AS date_created,
    t2.Email AS email,
    CONCAT(t2.FirstName, ' ', t2.Surname) AS full_name,
    CASE 
        WHEN t3.Category IS NULL OR t3.Name IS NULL THEN 'Intro Package'
        ELSE CONCAT(t3.Category, ' ', t3.Name, ' Access')
    END AS item_name,
    t1.PaymentAmount AS amount,
    t1.Method AS method,
    t1.RechargeSuccessful AS successful,
    t4.ServiceId AS service_id,
    t5.Name AS build_name,
    t6.Name AS build_type
FROM
    Recharges t1
LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
LEFT JOIN Products t3 ON t1.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t2.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND CAST(t1.DateCreated AS DATE) >= ?
    AND CAST(t1.DateCreated AS DATE) <= ?
    AND (
        t2.FirstName LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t2.Surname LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t2.Email LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.PaymentAmount LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.ServiceId LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t5.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t6.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
ORDER BY
    t1.DateCreated DESC
LIMIT ?
OFFSET ?
`

type GetReportsRechargesParams struct {
	Poi       string
	StartDate time.Time
	EndDate   time.Time
	Search    string
	Limit     int32
	Offset    int32
}

type GetReportsRechargesRow struct {
	DateCreated time.Time
	Email       sql.NullString
	FullName    string
	ItemName    interface{}
	Amount      sql.NullString
	Method      sql.NullString
	Successful  bool
	ServiceID   sql.NullInt64
	BuildName   sql.NullString
	BuildType   sql.NullString
}

func (q *Queries) GetReportsRecharges(ctx context.Context, arg GetReportsRechargesParams) ([]GetReportsRechargesRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsRecharges,
		arg.Poi,
		arg.StartDate,
		arg.EndDate,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsRechargesRow
	for rows.Next() {
		var i GetReportsRechargesRow
		if err := rows.Scan(
			&i.DateCreated,
			&i.Email,
			&i.FullName,
			&i.ItemName,
			&i.Amount,
			&i.Method,
			&i.Successful,
			&i.ServiceID,
			&i.BuildName,
			&i.BuildType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsRechargesSummary = `-- name: GetReportsRechargesSummary :many
SELECT
    t1.DateCreated AS date_created,
    t2.Email AS email,
    CONCAT(t2.FirstName, ' ', t2.Surname) AS full_name,
    CASE 
        WHEN t3.Category IS NULL OR t3.Name IS NULL THEN 'Intro Package'
        ELSE CONCAT(t3.Category, ' ', t3.Name, ' Access')
    END AS item_name,
    t1.PaymentAmount AS amount,
    t1.Method AS method,
    t1.RechargeSuccessful AS successful,
    t4.ServiceId AS service_id,
    t5.Name AS build_name,
    t6.Name AS build_type
FROM
    Recharges t1
LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
LEFT JOIN Products t3 ON t1.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t2.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND t1.DateCreated >= DATE_FORMAT(NOW(), '%Y-%m-01')
    AND (
        t2.FirstName LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t2.Surname LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t2.Email LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.PaymentAmount LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.ServiceId LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t5.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t6.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
ORDER BY
    t1.DateCreated DESC
LIMIT ?
OFFSET ?
`

type GetReportsRechargesSummaryParams struct {
	Poi    string
	Search string
	Limit  int32
	Offset int32
}

type GetReportsRechargesSummaryRow struct {
	DateCreated time.Time
	Email       sql.NullString
	FullName    string
	ItemName    interface{}
	Amount      sql.NullString
	Method      sql.NullString
	Successful  bool
	ServiceID   sql.NullInt64
	BuildName   sql.NullString
	BuildType   sql.NullString
}

func (q *Queries) GetReportsRechargesSummary(ctx context.Context, arg GetReportsRechargesSummaryParams) ([]GetReportsRechargesSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsRechargesSummary,
		arg.Poi,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsRechargesSummaryRow
	for rows.Next() {
		var i GetReportsRechargesSummaryRow
		if err := rows.Scan(
			&i.DateCreated,
			&i.Email,
			&i.FullName,
			&i.ItemName,
			&i.Amount,
			&i.Method,
			&i.Successful,
			&i.ServiceID,
			&i.BuildName,
			&i.BuildType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsSummary = `-- name: GetReportsSummary :many
SELECT
    t2.DateCreated AS date_created,
    CASE 
        WHEN t3.Category IS NULL OR t3.Name IS NULL THEN 'Intro Package'
        ELSE CONCAT(t3.Category, ' ', t3.Name, ' Access')
    END AS item_name,
    t4.RadiusUsername AS radius_username,
    t2.Method AS method,

    COALESCE(
        JSON_UNQUOTE(JSON_EXTRACT(t2.PaymentServicePayload, '$.amount_gross')),
        '0'
    ) AS amount_gross,

    COALESCE(
        JSON_UNQUOTE(JSON_EXTRACT(t2.PaymentServicePayload, '$.amount_fee')),
        '0'
    ) AS amount_fee,

    COALESCE(
        JSON_UNQUOTE(JSON_EXTRACT(t2.PaymentServicePayload, '$.amount_net')),
        '0'
    ) AS amount_net,

    COALESCE(
        JSON_UNQUOTE(JSON_EXTRACT(t2.PaymentServicePayload, '$.accountNumber')),
        '0'
    ) AS cash_code,

    CASE
        WHEN JSON_UNQUOTE(JSON_EXTRACT(t2.PaymentServicePayload, '$.tenders[0].amount')) IS NULL THEN '0'
        ELSE JSON_UNQUOTE(JSON_EXTRACT(t2.PaymentServicePayload, '$.tenders[0].amount'))
    END AS cash_amount,

    t4.ServiceId AS service_id,
    t5.Name AS build_name,
    t6.Name AS build_type
FROM Customers t1
LEFT JOIN Recharges t2 ON t1.Id = t2.CustomerID
LEFT JOIN Products t3 ON t2.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t1.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE 
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND t1.DateCreated >= 
        CASE 
            WHEN ? = 1 THEN DATE_FORMAT(NOW(), '%Y-%m-01 00:00:00')
            ELSE DATE_FORMAT(DATE_SUB(DATE_FORMAT(NOW(), '%Y-%m-01'), INTERVAL (? - 1) MONTH), '%Y-%m-01 00:00:00')
        END
    AND (
        CONCAT(t3.Category, ' ', t3.Name, ' Access') LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.RadiusUsername LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.ServiceId LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t5.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t6.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
    AND t2.RechargeSuccessful = 1
ORDER BY
    t2.DateCreated DESC
LIMIT ?
OFFSET ?
`

type GetReportsSummaryParams struct {
	Poi    string
	Months interface{}
	Search string
	Limit  int32
	Offset int32
}

type GetReportsSummaryRow struct {
	DateCreated    sql.NullTime
	ItemName       interface{}
	RadiusUsername sql.NullString
	Method         sql.NullString
	AmountGross    interface{}
	AmountFee      interface{}
	AmountNet      interface{}
	CashCode       interface{}
	CashAmount     interface{}
	ServiceID      sql.NullInt64
	BuildName      sql.NullString
	BuildType      sql.NullString
}

func (q *Queries) GetReportsSummary(ctx context.Context, arg GetReportsSummaryParams) ([]GetReportsSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsSummary,
		arg.Poi,
		arg.Months,
		arg.Months,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsSummaryRow
	for rows.Next() {
		var i GetReportsSummaryRow
		if err := rows.Scan(
			&i.DateCreated,
			&i.ItemName,
			&i.RadiusUsername,
			&i.Method,
			&i.AmountGross,
			&i.AmountFee,
			&i.AmountNet,
			&i.CashCode,
			&i.CashAmount,
			&i.ServiceID,
			&i.BuildName,
			&i.BuildType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsTotalCustomers = `-- name: GetReportsTotalCustomers :one
SELECT
    COUNT(*) AS total_customers
FROM Customers t1
LEFT JOIN Addresses t2 ON t1.AddressId = t2.Id
WHERE
    TRIM(LOWER(t2.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND (
        t1.FirstName LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Surname LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Email LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.PhoneNumber LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t2.RadiusUsername LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
ORDER BY
    t1.RadiusUsername ASC,
    t1.Email ASC
LIMIT 1
`

type GetReportsTotalCustomersParams struct {
	Poi    string
	Search string
}

func (q *Queries) GetReportsTotalCustomers(ctx context.Context, arg GetReportsTotalCustomersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReportsTotalCustomers,
		arg.Poi,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
	)
	var total_customers int64
	err := row.Scan(&total_customers)
	return total_customers, err
}

const getReportsTotalExpiringCustomers = `-- name: GetReportsTotalExpiringCustomers :one
SELECT
    COUNT(*) AS total_expiring_customers
FROM
    Customers t1
LEFT JOIN (
    SELECT
        CustomerID,
        MAX(DateCreated) AS LastRechargeDate
    FROM
        Recharges
    GROUP BY
        CustomerID
) AS latest_recharge ON t1.Id = latest_recharge.CustomerID
LEFT JOIN Recharges t2 ON latest_recharge.CustomerID = t2.CustomerID AND latest_recharge.LastRechargeDate = t2.DateCreated
LEFT JOIN Products t3 ON t2.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t1.AddressId = t4.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND (
        t1.FirstName LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Surname LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Email LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.PhoneNumber LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.RadiusUsername LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t3.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t3.Category LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
ORDER BY
    t4.RadiusUsername ASC,
    t1.Email ASC
LIMIT 1
`

type GetReportsTotalExpiringCustomersParams struct {
	Poi    string
	Search string
}

func (q *Queries) GetReportsTotalExpiringCustomers(ctx context.Context, arg GetReportsTotalExpiringCustomersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReportsTotalExpiringCustomers,
		arg.Poi,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
	)
	var total_expiring_customers int64
	err := row.Scan(&total_expiring_customers)
	return total_expiring_customers, err
}

const getReportsTotalRechargeSummaries = `-- name: GetReportsTotalRechargeSummaries :one
SELECT
    COUNT(*) AS total_recharge_summaries
FROM
    Recharges t1
LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
LEFT JOIN Products t3 ON t1.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t2.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND t1.DateCreated >= DATE_FORMAT(NOW(), '%Y-%m-01')
    AND (
        t2.FirstName LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t2.Surname LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t2.Email LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.PaymentAmount LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.ServiceId LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t5.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t6.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
ORDER BY
    t1.DateCreated DESC
LIMIT 1
`

type GetReportsTotalRechargeSummariesParams struct {
	Poi    string
	Search string
}

func (q *Queries) GetReportsTotalRechargeSummaries(ctx context.Context, arg GetReportsTotalRechargeSummariesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReportsTotalRechargeSummaries,
		arg.Poi,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
	)
	var total_recharge_summaries int64
	err := row.Scan(&total_recharge_summaries)
	return total_recharge_summaries, err
}

const getReportsTotalRecharges = `-- name: GetReportsTotalRecharges :one
SELECT
    COUNT(*) AS total_recharges
FROM
    Recharges t1
LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
LEFT JOIN Products t3 ON t1.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t2.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND CAST(t1.DateCreated AS DATE) >= ?
    AND CAST(t1.DateCreated AS DATE) <= ?
    AND (
        t2.FirstName LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t2.Surname LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.PaymentAmount LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.ServiceId LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t5.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t6.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
ORDER BY
    t1.DateCreated DESC
LIMIT 1
`

type GetReportsTotalRechargesParams struct {
	Poi       string
	StartDate time.Time
	EndDate   time.Time
	Search    string
}

func (q *Queries) GetReportsTotalRecharges(ctx context.Context, arg GetReportsTotalRechargesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReportsTotalRecharges,
		arg.Poi,
		arg.StartDate,
		arg.EndDate,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
	)
	var total_recharges int64
	err := row.Scan(&total_recharges)
	return total_recharges, err
}

const getReportsTotalSummaries = `-- name: GetReportsTotalSummaries :one
SELECT
    COUNT(*) AS total_summaries
FROM Customers t1
LEFT JOIN Recharges t2 ON t1.Id = t2.CustomerID
LEFT JOIN Products t3 ON t2.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t1.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE 
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND t1.DateCreated >= 
        CASE 
            WHEN ? = 1 THEN DATE_FORMAT(NOW(), '%Y-%m-01 00:00:00')
            ELSE DATE_FORMAT(DATE_SUB(DATE_FORMAT(NOW(), '%Y-%m-01'), INTERVAL (? - 1) MONTH), '%Y-%m-01 00:00:00')
        END
    AND (
        CONCAT(t3.Category, ' ', t3.Name, ' Access') LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.RadiusUsername LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.ServiceId LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t5.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t6.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
    AND t2.RechargeSuccessful = 1
ORDER BY
    t2.DateCreated DESC
LIMIT 1
`

type GetReportsTotalSummariesParams struct {
	Poi    string
	Months interface{}
	Search string
}

func (q *Queries) GetReportsTotalSummaries(ctx context.Context, arg GetReportsTotalSummariesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReportsTotalSummaries,
		arg.Poi,
		arg.Months,
		arg.Months,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
	)
	var total_summaries int64
	err := row.Scan(&total_summaries)
	return total_summaries, err
}
