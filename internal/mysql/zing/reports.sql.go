// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reports.sql

package zing

import (
	"context"
	"database/sql"
	"time"
)

const getReportsCustomers = `-- name: GetReportsCustomers :many
SELECT
    t1.id, t1.firstname, t1.surname, t1.password, t1.passwordsalt, t1.email, t1.phonenumber, t1.idnumber, t1.radiususername, t1.preferemailcommunication, t1.language, t1.registrationapproved, t1.registrationdeclined, t1.setownpassword, t1.subscriptiontoken, t1.proofofaddressdocumentid, t1.idbookdocumentid, t1.approvedbyuserid, t1.addressid, t1.potentialaddress, t1.salesagentid, t1.datecreated, t1.deleted,
    t2.RadiusUsername AS t2_radius_username
FROM Customers t1
LEFT JOIN Addresses t2 ON t1.AddressId = t2.Id
WHERE
    TRIM(LOWER(t2.POP)) LIKE CONCAT(TRIM(LOWER(?)), '%')
`

type GetReportsCustomersRow struct {
	ID                       string
	Firstname                sql.NullString
	Surname                  sql.NullString
	Password                 sql.NullString
	Passwordsalt             sql.NullString
	Email                    sql.NullString
	Phonenumber              sql.NullString
	Idnumber                 sql.NullString
	Radiususername           sql.NullString
	Preferemailcommunication bool
	Language                 sql.NullString
	Registrationapproved     bool
	Registrationdeclined     bool
	Setownpassword           bool
	Subscriptiontoken        sql.NullString
	Proofofaddressdocumentid sql.NullString
	Idbookdocumentid         sql.NullString
	Approvedbyuserid         sql.NullString
	Addressid                sql.NullString
	Potentialaddress         sql.NullString
	Salesagentid             sql.NullString
	Datecreated              time.Time
	Deleted                  bool
	T2RadiusUsername         sql.NullString
}

func (q *Queries) GetReportsCustomers(ctx context.Context, poi string) ([]GetReportsCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsCustomers, poi)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsCustomersRow
	for rows.Next() {
		var i GetReportsCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.Firstname,
			&i.Surname,
			&i.Password,
			&i.Passwordsalt,
			&i.Email,
			&i.Phonenumber,
			&i.Idnumber,
			&i.Radiususername,
			&i.Preferemailcommunication,
			&i.Language,
			&i.Registrationapproved,
			&i.Registrationdeclined,
			&i.Setownpassword,
			&i.Subscriptiontoken,
			&i.Proofofaddressdocumentid,
			&i.Idbookdocumentid,
			&i.Approvedbyuserid,
			&i.Addressid,
			&i.Potentialaddress,
			&i.Salesagentid,
			&i.Datecreated,
			&i.Deleted,
			&i.T2RadiusUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsExpiringCustomers = `-- name: GetReportsExpiringCustomers :many
SELECT
    t1.id, t1.firstname, t1.surname, t1.password, t1.passwordsalt, t1.email, t1.phonenumber, t1.idnumber, t1.radiususername, t1.preferemailcommunication, t1.language, t1.registrationapproved, t1.registrationdeclined, t1.setownpassword, t1.subscriptiontoken, t1.proofofaddressdocumentid, t1.idbookdocumentid, t1.approvedbyuserid, t1.addressid, t1.potentialaddress, t1.salesagentid, t1.datecreated, t1.deleted,
    t3.Name AS last_purchase_duration,
    t3.Category AS last_purchase_speed,
    t4.RadiusUsername AS t4_radius_username,
    CONCAT(?) AS expiration,
    CONCAT(?) AS address
FROM
    Customers t1
LEFT JOIN (
    SELECT
        CustomerID,
        MAX(DateCreated) AS LastRechargeDate
    FROM
        Recharges
    GROUP BY
        CustomerID
) AS latest_recharge ON t1.Id = latest_recharge.CustomerID
LEFT JOIN Recharges t2 ON latest_recharge.CustomerID = t2.CustomerID AND latest_recharge.LastRechargeDate = t2.DateCreated
LEFT JOIN Products t3 ON t2.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t1.AddressId = t4.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT(TRIM(LOWER(?)),'%')
`

type GetReportsExpiringCustomersParams struct {
	Expiration interface{}
	Address    interface{}
	Poi        string
}

type GetReportsExpiringCustomersRow struct {
	ID                       string
	Firstname                sql.NullString
	Surname                  sql.NullString
	Password                 sql.NullString
	Passwordsalt             sql.NullString
	Email                    sql.NullString
	Phonenumber              sql.NullString
	Idnumber                 sql.NullString
	Radiususername           sql.NullString
	Preferemailcommunication bool
	Language                 sql.NullString
	Registrationapproved     bool
	Registrationdeclined     bool
	Setownpassword           bool
	Subscriptiontoken        sql.NullString
	Proofofaddressdocumentid sql.NullString
	Idbookdocumentid         sql.NullString
	Approvedbyuserid         sql.NullString
	Addressid                sql.NullString
	Potentialaddress         sql.NullString
	Salesagentid             sql.NullString
	Datecreated              time.Time
	Deleted                  bool
	LastPurchaseDuration     sql.NullString
	LastPurchaseSpeed        sql.NullString
	T4RadiusUsername         sql.NullString
	Expiration               string
	Address                  string
}

func (q *Queries) GetReportsExpiringCustomers(ctx context.Context, arg GetReportsExpiringCustomersParams) ([]GetReportsExpiringCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsExpiringCustomers, arg.Expiration, arg.Address, arg.Poi)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsExpiringCustomersRow
	for rows.Next() {
		var i GetReportsExpiringCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.Firstname,
			&i.Surname,
			&i.Password,
			&i.Passwordsalt,
			&i.Email,
			&i.Phonenumber,
			&i.Idnumber,
			&i.Radiususername,
			&i.Preferemailcommunication,
			&i.Language,
			&i.Registrationapproved,
			&i.Registrationdeclined,
			&i.Setownpassword,
			&i.Subscriptiontoken,
			&i.Proofofaddressdocumentid,
			&i.Idbookdocumentid,
			&i.Approvedbyuserid,
			&i.Addressid,
			&i.Potentialaddress,
			&i.Salesagentid,
			&i.Datecreated,
			&i.Deleted,
			&i.LastPurchaseDuration,
			&i.LastPurchaseSpeed,
			&i.T4RadiusUsername,
			&i.Expiration,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsRechargeTypeCounts = `-- name: GetReportsRechargeTypeCounts :many
SELECT
	recharge_name, recharge_count, recharge_period, recharge_max_date
FROM
	(
		SELECT
			t3.Name AS recharge_name,
			COUNT(*) AS recharge_count,
			CASE
				WHEN ? = 'weeks' THEN CONCAT(
					FLOOR((DAY(t1.DateCreated) - 1) / 7) + 1,
					'-',
					MONTH(t1.DateCreated),
					'-',
					YEAR(t1.DateCreated)
				)
				WHEN ? = 'months' THEN CONCAT(MONTH(t1.DateCreated), '-', YEAR(t1.DateCreated))
			END AS recharge_period,
			MAX(t1.DateCreated) AS recharge_max_date
		FROM
			Recharges t1
			LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
			LEFT JOIN Products t3 ON t1.ProductId = t3.Id
		WHERE
			TRIM(LOWER(t2.RadiusUsername)) LIKE CONCAT(TRIM(LOWER(?)), '%')
			AND(
                (
                    ? = 'weeks'
                    AND t1.DateCreated >= DATE_SUB(DATE_SUB(CURDATE(), INTERVAL WEEKDAY(CURDATE()) DAY), INTERVAL (? - 1) WEEK)
                )
                OR(
                    ? = 'months'
                    AND t1.DateCreated >= DATE_SUB(DATE_SUB(CURDATE(), INTERVAL DAY(CURDATE()) - 1 DAY), INTERVAL (? - 1) MONTH)
                )
			)
		GROUP BY
			recharge_name,
			recharge_period
	) AS sub
ORDER BY
	recharge_max_date ASC,
    recharge_count DESC
`

type GetReportsRechargeTypeCountsParams struct {
	Period interface{}
	Poi    string
	Count  interface{}
}

type GetReportsRechargeTypeCountsRow struct {
	RechargeName    sql.NullString
	RechargeCount   int64
	RechargePeriod  interface{}
	RechargeMaxDate interface{}
}

func (q *Queries) GetReportsRechargeTypeCounts(ctx context.Context, arg GetReportsRechargeTypeCountsParams) ([]GetReportsRechargeTypeCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsRechargeTypeCounts,
		arg.Period,
		arg.Period,
		arg.Poi,
		arg.Period,
		arg.Count,
		arg.Period,
		arg.Count,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsRechargeTypeCountsRow
	for rows.Next() {
		var i GetReportsRechargeTypeCountsRow
		if err := rows.Scan(
			&i.RechargeName,
			&i.RechargeCount,
			&i.RechargePeriod,
			&i.RechargeMaxDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsRecharges = `-- name: GetReportsRecharges :many
SELECT
    t2.RadiusUsername AS radius_username,
    t1.DateCreated AS date_created,
    CONCAT(t3.Category, ' ', t3.Name, ' Access') AS item_name,
    t1.id, t1.customerid, t1.productid, t1.method, t1.paymentservicepaymentid, t1.paymentservicepayload, t1.paymentservicequeryparams, t1.rechargesuccessful, t1.failurereason, t1.paymentamount, t1.expirydate, t1.previousrmexpirydate, t1.userid, t1.fromrmsvcid, t1.tormsvcid, t1.datecreated, t1.deleted,
    t2.id, t2.firstname, t2.surname, t2.password, t2.passwordsalt, t2.email, t2.phonenumber, t2.idnumber, t2.radiususername, t2.preferemailcommunication, t2.language, t2.registrationapproved, t2.registrationdeclined, t2.setownpassword, t2.subscriptiontoken, t2.proofofaddressdocumentid, t2.idbookdocumentid, t2.approvedbyuserid, t2.addressid, t2.potentialaddress, t2.salesagentid, t2.datecreated, t2.deleted,
    t4.ServiceId AS service_id,
    t5.Name AS build_name,
    t6.Name AS build_type
FROM
    Recharges t1
LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
LEFT JOIN Products t3 ON t1.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t2.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT(TRIM(LOWER(?)), '%')
    AND CAST(t1.DateCreated AS DATE) >= ?
    AND CAST(t1.DateCreated AS DATE) <= ?
ORDER BY
    t1.DateCreated DESC
`

type GetReportsRechargesParams struct {
	Poi       string
	StartDate time.Time
	EndDate   time.Time
}

type GetReportsRechargesRow struct {
	RadiusUsername            sql.NullString
	DateCreated               time.Time
	ItemName                  string
	ID                        string
	Customerid                sql.NullString
	Productid                 sql.NullString
	Method                    sql.NullString
	Paymentservicepaymentid   sql.NullString
	Paymentservicepayload     sql.NullString
	Paymentservicequeryparams sql.NullString
	Rechargesuccessful        bool
	Failurereason             sql.NullString
	Paymentamount             sql.NullString
	Expirydate                sql.NullTime
	Previousrmexpirydate      sql.NullTime
	Userid                    sql.NullString
	Fromrmsvcid               sql.NullInt32
	Tormsvcid                 sql.NullInt32
	Datecreated               time.Time
	Deleted                   bool
	ID_2                      sql.NullString
	Firstname                 sql.NullString
	Surname                   sql.NullString
	Password                  sql.NullString
	Passwordsalt              sql.NullString
	Email                     sql.NullString
	Phonenumber               sql.NullString
	Idnumber                  sql.NullString
	Radiususername            sql.NullString
	Preferemailcommunication  sql.NullBool
	Language                  sql.NullString
	Registrationapproved      sql.NullBool
	Registrationdeclined      sql.NullBool
	Setownpassword            sql.NullBool
	Subscriptiontoken         sql.NullString
	Proofofaddressdocumentid  sql.NullString
	Idbookdocumentid          sql.NullString
	Approvedbyuserid          sql.NullString
	Addressid                 sql.NullString
	Potentialaddress          sql.NullString
	Salesagentid              sql.NullString
	Datecreated_2             sql.NullTime
	Deleted_2                 sql.NullBool
	ServiceID                 sql.NullInt64
	BuildName                 sql.NullString
	BuildType                 sql.NullString
}

func (q *Queries) GetReportsRecharges(ctx context.Context, arg GetReportsRechargesParams) ([]GetReportsRechargesRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsRecharges, arg.Poi, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsRechargesRow
	for rows.Next() {
		var i GetReportsRechargesRow
		if err := rows.Scan(
			&i.RadiusUsername,
			&i.DateCreated,
			&i.ItemName,
			&i.ID,
			&i.Customerid,
			&i.Productid,
			&i.Method,
			&i.Paymentservicepaymentid,
			&i.Paymentservicepayload,
			&i.Paymentservicequeryparams,
			&i.Rechargesuccessful,
			&i.Failurereason,
			&i.Paymentamount,
			&i.Expirydate,
			&i.Previousrmexpirydate,
			&i.Userid,
			&i.Fromrmsvcid,
			&i.Tormsvcid,
			&i.Datecreated,
			&i.Deleted,
			&i.ID_2,
			&i.Firstname,
			&i.Surname,
			&i.Password,
			&i.Passwordsalt,
			&i.Email,
			&i.Phonenumber,
			&i.Idnumber,
			&i.Radiususername,
			&i.Preferemailcommunication,
			&i.Language,
			&i.Registrationapproved,
			&i.Registrationdeclined,
			&i.Setownpassword,
			&i.Subscriptiontoken,
			&i.Proofofaddressdocumentid,
			&i.Idbookdocumentid,
			&i.Approvedbyuserid,
			&i.Addressid,
			&i.Potentialaddress,
			&i.Salesagentid,
			&i.Datecreated_2,
			&i.Deleted_2,
			&i.ServiceID,
			&i.BuildName,
			&i.BuildType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsRechargesSummary = `-- name: GetReportsRechargesSummary :many
SELECT
    t2.RadiusUsername AS radius_username,
    t1.DateCreated AS date_created,
    CONCAT(t3.Category, ' ', t3.Name, ' Access') as item_name,
    t1.id, t1.customerid, t1.productid, t1.method, t1.paymentservicepaymentid, t1.paymentservicepayload, t1.paymentservicequeryparams, t1.rechargesuccessful, t1.failurereason, t1.paymentamount, t1.expirydate, t1.previousrmexpirydate, t1.userid, t1.fromrmsvcid, t1.tormsvcid, t1.datecreated, t1.deleted,
    t2.id, t2.firstname, t2.surname, t2.password, t2.passwordsalt, t2.email, t2.phonenumber, t2.idnumber, t2.radiususername, t2.preferemailcommunication, t2.language, t2.registrationapproved, t2.registrationdeclined, t2.setownpassword, t2.subscriptiontoken, t2.proofofaddressdocumentid, t2.idbookdocumentid, t2.approvedbyuserid, t2.addressid, t2.potentialaddress, t2.salesagentid, t2.datecreated, t2.deleted,
    t4.ServiceId AS service_id,
    t5.Name AS build_name,
    t6.Name AS build_type
FROM
    Recharges t1
LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
LEFT JOIN Products t3 ON t1.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t2.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT(TRIM(LOWER(?)), '%')
    AND t1.DateCreated >= DATE_FORMAT(NOW(), '%Y-%m-01')
ORDER BY
    t1.DateCreated DESC
`

type GetReportsRechargesSummaryRow struct {
	RadiusUsername            sql.NullString
	DateCreated               time.Time
	ItemName                  string
	ID                        string
	Customerid                sql.NullString
	Productid                 sql.NullString
	Method                    sql.NullString
	Paymentservicepaymentid   sql.NullString
	Paymentservicepayload     sql.NullString
	Paymentservicequeryparams sql.NullString
	Rechargesuccessful        bool
	Failurereason             sql.NullString
	Paymentamount             sql.NullString
	Expirydate                sql.NullTime
	Previousrmexpirydate      sql.NullTime
	Userid                    sql.NullString
	Fromrmsvcid               sql.NullInt32
	Tormsvcid                 sql.NullInt32
	Datecreated               time.Time
	Deleted                   bool
	ID_2                      sql.NullString
	Firstname                 sql.NullString
	Surname                   sql.NullString
	Password                  sql.NullString
	Passwordsalt              sql.NullString
	Email                     sql.NullString
	Phonenumber               sql.NullString
	Idnumber                  sql.NullString
	Radiususername            sql.NullString
	Preferemailcommunication  sql.NullBool
	Language                  sql.NullString
	Registrationapproved      sql.NullBool
	Registrationdeclined      sql.NullBool
	Setownpassword            sql.NullBool
	Subscriptiontoken         sql.NullString
	Proofofaddressdocumentid  sql.NullString
	Idbookdocumentid          sql.NullString
	Approvedbyuserid          sql.NullString
	Addressid                 sql.NullString
	Potentialaddress          sql.NullString
	Salesagentid              sql.NullString
	Datecreated_2             sql.NullTime
	Deleted_2                 sql.NullBool
	ServiceID                 sql.NullInt64
	BuildName                 sql.NullString
	BuildType                 sql.NullString
}

func (q *Queries) GetReportsRechargesSummary(ctx context.Context, poi string) ([]GetReportsRechargesSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsRechargesSummary, poi)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsRechargesSummaryRow
	for rows.Next() {
		var i GetReportsRechargesSummaryRow
		if err := rows.Scan(
			&i.RadiusUsername,
			&i.DateCreated,
			&i.ItemName,
			&i.ID,
			&i.Customerid,
			&i.Productid,
			&i.Method,
			&i.Paymentservicepaymentid,
			&i.Paymentservicepayload,
			&i.Paymentservicequeryparams,
			&i.Rechargesuccessful,
			&i.Failurereason,
			&i.Paymentamount,
			&i.Expirydate,
			&i.Previousrmexpirydate,
			&i.Userid,
			&i.Fromrmsvcid,
			&i.Tormsvcid,
			&i.Datecreated,
			&i.Deleted,
			&i.ID_2,
			&i.Firstname,
			&i.Surname,
			&i.Password,
			&i.Passwordsalt,
			&i.Email,
			&i.Phonenumber,
			&i.Idnumber,
			&i.Radiususername,
			&i.Preferemailcommunication,
			&i.Language,
			&i.Registrationapproved,
			&i.Registrationdeclined,
			&i.Setownpassword,
			&i.Subscriptiontoken,
			&i.Proofofaddressdocumentid,
			&i.Idbookdocumentid,
			&i.Approvedbyuserid,
			&i.Addressid,
			&i.Potentialaddress,
			&i.Salesagentid,
			&i.Datecreated_2,
			&i.Deleted_2,
			&i.ServiceID,
			&i.BuildName,
			&i.BuildType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsSummary = `-- name: GetReportsSummary :many
SELECT
    t1.RadiusUsername AS radius_username,
    t2.DateCreated AS date_created,

    CASE WHEN JSON_VALID(PaymentServicePayload) = 1
        THEN CONCAT(t3.Category, ' ', t3.Name, ' Access')
        ELSE 'Intro Package'
    END AS item_name,

    CASE WHEN JSON_VALID(PaymentServicePayload) = 1 
        THEN JSON_VALUE(PaymentServicePayload, '$.amount_gross') 
        ELSE '0' 
    END AS amount_gross,

    CASE WHEN JSON_VALID(PaymentServicePayload) = 1 
        THEN JSON_VALUE(PaymentServicePayload, '$.amount_fee') 
        ELSE '0.0' 
    END AS amount_fee,

    CASE WHEN JSON_VALID(PaymentServicePayload) = 1 
        THEN JSON_VALUE(PaymentServicePayload, '$.amount_net') 
        ELSE '0' 
    END AS amount_net,

    CASE WHEN JSON_VALID(PaymentServicePayload) = 1 
        THEN JSON_VALUE(PaymentServicePayload, '$.accountNumber') 
        ELSE '0'
    END AS cash_code,

    CASE 
        WHEN
            JSON_VALID(PaymentServicePayload) = 1 
            AND JSON_VALUE(PaymentServicePayload, '$.tenders[0].amount') REGEXP '^[0-9]+(\\.[0-9]+)?$'
        THEN 
            CAST(JSON_VALUE(PaymentServicePayload, '$.tenders[0].amount') AS DECIMAL(10,2)) / 100
        ELSE 0
    END AS cash_amount,

    t4.ServiceId AS service_id,
    t5.Name AS build_name,
    t6.Name AS build_type
FROM Customers t1
LEFT JOIN Recharges t2 ON t1.Id = t2.CustomerID
LEFT JOIN Products t3 ON t2.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t1.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE 
    TRIM(LOWER(t4.POP)) LIKE CONCAT(TRIM(LOWER(?)), '%')
    AND t2.DateCreated >= DATE_FORMAT(NOW(), '%Y-%m-01')
ORDER BY
    t2.DateCreated DESC
`

type GetReportsSummaryRow struct {
	RadiusUsername sql.NullString
	DateCreated    sql.NullTime
	ItemName       string
	AmountGross    string
	AmountFee      string
	AmountNet      string
	CashCode       string
	CashAmount     int32
	ServiceID      sql.NullInt64
	BuildName      sql.NullString
	BuildType      sql.NullString
}

func (q *Queries) GetReportsSummary(ctx context.Context, poi string) ([]GetReportsSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportsSummary, poi)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportsSummaryRow
	for rows.Next() {
		var i GetReportsSummaryRow
		if err := rows.Scan(
			&i.RadiusUsername,
			&i.DateCreated,
			&i.ItemName,
			&i.AmountGross,
			&i.AmountFee,
			&i.AmountNet,
			&i.CashCode,
			&i.CashAmount,
			&i.ServiceID,
			&i.BuildName,
			&i.BuildType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsUnregisteredCustomers = `-- name: GetReportsUnregisteredCustomers :many
SELECT
    t1.id, t1.firstname, t1.surname, t1.password, t1.passwordsalt, t1.email, t1.phonenumber, t1.idnumber, t1.radiususername, t1.preferemailcommunication, t1.language, t1.registrationapproved, t1.registrationdeclined, t1.setownpassword, t1.subscriptiontoken, t1.proofofaddressdocumentid, t1.idbookdocumentid, t1.approvedbyuserid, t1.addressid, t1.potentialaddress, t1.salesagentid, t1.datecreated, t1.deleted
FROM
    Customers t1
LEFT JOIN Addresses t2 ON t1.AddressId = t2.Id
WHERE
    TRIM(LOWER(t2.POP)) LIKE CONCAT(TRIM(LOWER(?)),'%')
`

func (q *Queries) GetReportsUnregisteredCustomers(ctx context.Context, poi string) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, getReportsUnregisteredCustomers, poi)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Firstname,
			&i.Surname,
			&i.Password,
			&i.Passwordsalt,
			&i.Email,
			&i.Phonenumber,
			&i.Idnumber,
			&i.Radiususername,
			&i.Preferemailcommunication,
			&i.Language,
			&i.Registrationapproved,
			&i.Registrationdeclined,
			&i.Setownpassword,
			&i.Subscriptiontoken,
			&i.Proofofaddressdocumentid,
			&i.Idbookdocumentid,
			&i.Approvedbyuserid,
			&i.Addressid,
			&i.Potentialaddress,
			&i.Salesagentid,
			&i.Datecreated,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
