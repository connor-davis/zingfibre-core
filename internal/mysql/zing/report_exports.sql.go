// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: report_exports.sql

package zing

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const getReportExportsCustomers = `-- name: GetReportExportsCustomers :many
SELECT
    CONCAT(t1.FirstName, ' ', t1.Surname) AS full_name,
    t1.Email AS email,
    t2.RadiusUsername AS radius_username,
    t1.PhoneNumber AS phone_number
FROM Customers t1
LEFT JOIN Addresses t2 ON t1.AddressId = t2.Id
WHERE
    TRIM(LOWER(t2.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
ORDER BY
    CONCAT(t1.FirstName, ' ', t1.Surname) ASC,
    t1.Email ASC
`

type GetReportExportsCustomersRow struct {
	FullName       string
	Email          sql.NullString
	RadiusUsername sql.NullString
	PhoneNumber    sql.NullString
}

func (q *Queries) GetReportExportsCustomers(ctx context.Context, poi string) ([]GetReportExportsCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportExportsCustomers, poi)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportExportsCustomersRow
	for rows.Next() {
		var i GetReportExportsCustomersRow
		if err := rows.Scan(
			&i.FullName,
			&i.Email,
			&i.RadiusUsername,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportExportsExpiringCustomers = `-- name: GetReportExportsExpiringCustomers :many
SELECT
    CONCAT(t1.FirstName, ' ', t1.Surname) AS full_name,
    t1.Email AS email,
    t1.PhoneNumber AS phone_number,
    t4.RadiusUsername AS radius_username,
    t3.Name AS last_purchase_duration,
    t3.Category AS last_purchase_speed,
    t4.StreetAddress AS Address,
    CONCAT('') AS expiration
FROM
    Customers t1
LEFT JOIN (
    SELECT
        CustomerID,
        MAX(DateCreated) AS LastRechargeDate
    FROM
        Recharges
    GROUP BY
        CustomerID
) AS latest_recharge ON t1.Id = latest_recharge.CustomerID
LEFT JOIN Recharges t2 ON latest_recharge.CustomerID = t2.CustomerID AND latest_recharge.LastRechargeDate = t2.DateCreated
LEFT JOIN Products t3 ON t2.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t1.AddressId = t4.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND (
        t1.FirstName LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Surname LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.Email LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t1.PhoneNumber LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t4.RadiusUsername LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t3.Name LIKE CONCAT('%', TRIM(LOWER(?)), '%')
        OR t3.Category LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    )
    AND t4.RadiusUsername IN (/*SLICE:radius_usernames*/?)
ORDER BY
    CONCAT(t1.FirstName, ' ', t1.Surname) ASC,
    t1.Email ASC
`

type GetReportExportsExpiringCustomersParams struct {
	Poi             string
	Search          string
	RadiusUsernames []sql.NullString
}

type GetReportExportsExpiringCustomersRow struct {
	FullName             string
	Email                sql.NullString
	PhoneNumber          sql.NullString
	RadiusUsername       sql.NullString
	LastPurchaseDuration sql.NullString
	LastPurchaseSpeed    sql.NullString
	Address              sql.NullString
	Expiration           string
}

func (q *Queries) GetReportExportsExpiringCustomers(ctx context.Context, arg GetReportExportsExpiringCustomersParams) ([]GetReportExportsExpiringCustomersRow, error) {
	query := getReportExportsExpiringCustomers
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Poi)
	queryParams = append(queryParams, arg.Search)
	queryParams = append(queryParams, arg.Search)
	queryParams = append(queryParams, arg.Search)
	queryParams = append(queryParams, arg.Search)
	queryParams = append(queryParams, arg.Search)
	queryParams = append(queryParams, arg.Search)
	queryParams = append(queryParams, arg.Search)
	if len(arg.RadiusUsernames) > 0 {
		for _, v := range arg.RadiusUsernames {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:radius_usernames*/?", strings.Repeat(",?", len(arg.RadiusUsernames))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:radius_usernames*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportExportsExpiringCustomersRow
	for rows.Next() {
		var i GetReportExportsExpiringCustomersRow
		if err := rows.Scan(
			&i.FullName,
			&i.Email,
			&i.PhoneNumber,
			&i.RadiusUsername,
			&i.LastPurchaseDuration,
			&i.LastPurchaseSpeed,
			&i.Address,
			&i.Expiration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportExportsRecharges = `-- name: GetReportExportsRecharges :many
SELECT
    t1.DateCreated AS date_created,
    t2.Email AS email,
    CONCAT(t2.FirstName, ' ', t2.Surname) AS full_name,
    CASE 
        WHEN t3.Category IS NULL OR t3.Name IS NULL THEN 'Intro Package'
        ELSE CONCAT(t3.Category, ' ', t3.Name, ' Access')
    END AS item_name,
    t1.PaymentAmount AS amount,
    t1.Method AS method,
    t1.RechargeSuccessful AS successful,
    t4.ServiceId AS service_id,
    t5.Name AS build_name,
    t6.Name AS build_type
FROM
    Recharges t1
LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
LEFT JOIN Products t3 ON t1.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t2.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND CAST(t1.DateCreated AS DATE) >= ?
    AND CAST(t1.DateCreated AS DATE) <= ?
ORDER BY
    t1.DateCreated DESC
`

type GetReportExportsRechargesParams struct {
	Poi       string
	StartDate time.Time
	EndDate   time.Time
}

type GetReportExportsRechargesRow struct {
	DateCreated time.Time
	Email       sql.NullString
	FullName    string
	ItemName    interface{}
	Amount      sql.NullString
	Method      sql.NullString
	Successful  bool
	ServiceID   sql.NullInt64
	BuildName   sql.NullString
	BuildType   sql.NullString
}

func (q *Queries) GetReportExportsRecharges(ctx context.Context, arg GetReportExportsRechargesParams) ([]GetReportExportsRechargesRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportExportsRecharges, arg.Poi, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportExportsRechargesRow
	for rows.Next() {
		var i GetReportExportsRechargesRow
		if err := rows.Scan(
			&i.DateCreated,
			&i.Email,
			&i.FullName,
			&i.ItemName,
			&i.Amount,
			&i.Method,
			&i.Successful,
			&i.ServiceID,
			&i.BuildName,
			&i.BuildType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportExportsRechargesSummary = `-- name: GetReportExportsRechargesSummary :many
SELECT
    t1.DateCreated AS date_created,
    t2.Email AS email,
    CONCAT(t2.FirstName, ' ', t2.Surname) AS full_name,
    CASE 
        WHEN t3.Category IS NULL OR t3.Name IS NULL THEN 'Intro Package'
        ELSE CONCAT(t3.Category, ' ', t3.Name, ' Access')
    END AS item_name,
    t1.PaymentAmount AS amount,
    t1.Method AS method,
    t1.RechargeSuccessful AS successful,
    t4.ServiceId AS service_id,
    t5.Name AS build_name,
    t6.Name AS build_type
FROM
    Recharges t1
LEFT JOIN Customers t2 ON t1.CustomerId = t2.Id
LEFT JOIN Products t3 ON t1.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t2.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND t1.DateCreated >= DATE_FORMAT(NOW(), '%Y-%m-01')
ORDER BY
    t1.DateCreated DESC
`

type GetReportExportsRechargesSummaryRow struct {
	DateCreated time.Time
	Email       sql.NullString
	FullName    string
	ItemName    interface{}
	Amount      sql.NullString
	Method      sql.NullString
	Successful  bool
	ServiceID   sql.NullInt64
	BuildName   sql.NullString
	BuildType   sql.NullString
}

func (q *Queries) GetReportExportsRechargesSummary(ctx context.Context, poi string) ([]GetReportExportsRechargesSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportExportsRechargesSummary, poi)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportExportsRechargesSummaryRow
	for rows.Next() {
		var i GetReportExportsRechargesSummaryRow
		if err := rows.Scan(
			&i.DateCreated,
			&i.Email,
			&i.FullName,
			&i.ItemName,
			&i.Amount,
			&i.Method,
			&i.Successful,
			&i.ServiceID,
			&i.BuildName,
			&i.BuildType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportExportsSummary = `-- name: GetReportExportsSummary :many
SELECT
    t2.DateCreated AS date_created,
    CASE 
        WHEN t3.Category IS NULL OR t3.Name IS NULL THEN 'Intro Package'
        ELSE CONCAT(t3.Category, ' ', t3.Name, ' Access')
    END AS item_name,
    t4.RadiusUsername AS radius_username,
    t2.Method AS method,
    t2.PaymentAmount AS amount,
    t4.ServiceId AS service_id,
    t5.Name AS build_name,
    t6.Name AS build_type
FROM Customers t1
LEFT JOIN Recharges t2 ON t1.Id = t2.CustomerID
LEFT JOIN Products t3 ON t2.ProductId = t3.Id
LEFT JOIN Addresses t4 ON t1.AddressId = t4.Id
LEFT JOIN Builds t5 ON t4.BuildId = t5.Id
LEFT JOIN BuildTypes t6 ON t5.BuildTypeId = t6.Id
WHERE 
    TRIM(LOWER(t4.POP)) LIKE CONCAT('%', TRIM(LOWER(?)), '%')
    AND t2.DateCreated >= 
        CASE 
            WHEN ? = 1 THEN DATE_FORMAT(NOW(), '%Y-%m-01 00:00:00')
            ELSE DATE_FORMAT(DATE_SUB(DATE_FORMAT(NOW(), '%Y-%m-01'), INTERVAL (? - 1) MONTH), '%Y-%m-01 00:00:00')
        END
    AND t2.RechargeSuccessful = 1
ORDER BY
    t2.DateCreated DESC
`

type GetReportExportsSummaryParams struct {
	Poi    string
	Months interface{}
}

type GetReportExportsSummaryRow struct {
	DateCreated    sql.NullTime
	ItemName       interface{}
	RadiusUsername sql.NullString
	Method         sql.NullString
	Amount         sql.NullString
	ServiceID      sql.NullInt64
	BuildName      sql.NullString
	BuildType      sql.NullString
}

func (q *Queries) GetReportExportsSummary(ctx context.Context, arg GetReportExportsSummaryParams) ([]GetReportExportsSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportExportsSummary, arg.Poi, arg.Months, arg.Months)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportExportsSummaryRow
	for rows.Next() {
		var i GetReportExportsSummaryRow
		if err := rows.Scan(
			&i.DateCreated,
			&i.ItemName,
			&i.RadiusUsername,
			&i.Method,
			&i.Amount,
			&i.ServiceID,
			&i.BuildName,
			&i.BuildType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
