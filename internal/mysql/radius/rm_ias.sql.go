// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rm_ias.sql

package radius

import (
	"context"
)

const getRmIa = `-- name: GetRmIa :one
SELECT
    iasid, iasname, price, downlimit, uplimit, comblimit, uptimelimit, expiretime, timebaseonline, timebaseexp, srvid, enableias, expiremode, expiration, simuse
FROM
    rm_ias
WHERE
    iasid = ?
LIMIT
    1
`

func (q *Queries) GetRmIa(ctx context.Context, iasid int32) (RmIa, error) {
	row := q.db.QueryRowContext(ctx, getRmIa, iasid)
	var i RmIa
	err := row.Scan(
		&i.Iasid,
		&i.Iasname,
		&i.Price,
		&i.Downlimit,
		&i.Uplimit,
		&i.Comblimit,
		&i.Uptimelimit,
		&i.Expiretime,
		&i.Timebaseonline,
		&i.Timebaseexp,
		&i.Srvid,
		&i.Enableias,
		&i.Expiremode,
		&i.Expiration,
		&i.Simuse,
	)
	return i, err
}

const getRmIas = `-- name: GetRmIas :many
SELECT
    iasid, iasname, price, downlimit, uplimit, comblimit, uptimelimit, expiretime, timebaseonline, timebaseexp, srvid, enableias, expiremode, expiration, simuse
FROM
    rm_ias
LIMIT
    ?
OFFSET
    ?
`

type GetRmIasParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetRmIas(ctx context.Context, arg GetRmIasParams) ([]RmIa, error) {
	rows, err := q.db.QueryContext(ctx, getRmIas, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RmIa
	for rows.Next() {
		var i RmIa
		if err := rows.Scan(
			&i.Iasid,
			&i.Iasname,
			&i.Price,
			&i.Downlimit,
			&i.Uplimit,
			&i.Comblimit,
			&i.Uptimelimit,
			&i.Expiretime,
			&i.Timebaseonline,
			&i.Timebaseexp,
			&i.Srvid,
			&i.Enableias,
			&i.Expiremode,
			&i.Expiration,
			&i.Simuse,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
